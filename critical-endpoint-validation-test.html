<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRITICAL: Endpoint Routing Validation Test</title>
    <style>
        body {
            font-family: system-ui, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }
        .container {
            background: rgba(255,255,255,0.95);
            padding: 2rem;
            border-radius: 12px;
            color: #333;
            margin-bottom: 2rem;
        }
        h1 { color: #dc2626; margin-bottom: 1rem; }
        .test-section {
            margin: 1rem 0;
            padding: 1rem;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background: #f7fafc;
        }
        button {
            background: #dc2626;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            margin: 0.5rem;
            font-weight: bold;
        }
        button:hover { background: #b91c1c; }
        button.success { background: #059669; }
        button.success:hover { background: #047857; }
        .status { 
            padding: 1rem; 
            margin: 1rem 0; 
            border-radius: 6px; 
            background: #fef2f2;
            border: 1px solid #dc2626;
        }
        .network-log {
            background: #1f2937;
            color: #f9fafb;
            padding: 1rem;
            border-radius: 6px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.85rem;
            max-height: 400px;
            overflow-y: auto;
            margin: 1rem 0;
        }
        .endpoint-valid { color: #10b981; font-weight: bold; }
        .endpoint-invalid { color: #ef4444; font-weight: bold; }
        .conversation-turn {
            border: 2px solid #3b82f6;
            margin: 1rem 0;
            padding: 1rem;
            border-radius: 6px;
            background: #eff6ff;
        }
        .timer {
            font-size: 1.2rem;
            font-weight: bold;
            color: #dc2626;
            text-align: center;
            margin: 1rem 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üö® CRITICAL: Endpoint Routing Validation Test</h1>
        <p><strong>EMERGENCY SECURITY RESPONSE VALIDATION</strong></p>
        <p>Testing Phase 1 JWT token fixes and verifying staging tests hit ONLY staging endpoints.</p>
        
        <div class="test-section">
            <h3>Test Status & Network Monitoring</h3>
            <div id="status" class="status">
                ‚è≥ Initializing critical endpoint validation test...
            </div>
            <div class="timer" id="timer">Timer: 00:00</div>
        </div>

        <div class="test-section">
            <h3>4-Turn Conversation Test Controls</h3>
            <button id="startTest" onclick="startConversationTest()">üöÄ START CRITICAL VALIDATION</button>
            <button id="turn1Btn" onclick="executeTurn1()" disabled>Turn 1: Initial Contact</button>
            <button id="turn2Btn" onclick="executeTurn2()" disabled>Turn 2: Memory Test</button>
            <button id="turn3Btn" onclick="executeTurn3()" disabled>Turn 3: 15-Min Threshold</button>
            <button id="turn4Btn" onclick="executeTurn4()" disabled>Turn 4: 30-Min Validation</button>
        </div>

        <div class="test-section">
            <h3>Live Network Traffic Monitor</h3>
            <div id="networkLog" class="network-log">Network monitoring will begin when test starts...</div>
        </div>

        <div class="test-section">
            <h3>Conversation Turns</h3>
            <div id="conversationTurns"></div>
        </div>

        <div class="test-section">
            <h3>Test Results</h3>
            <div id="results"></div>
        </div>
    </div>

    <!-- Load the Picasso Widget with MyRecruiter demo tenant -->
    <script src="/widget.js" data-tenant="my87674d777bf9" data-env="staging"></script>
    
    <script>
        class EndpointValidationTest {
            constructor() {
                this.startTime = null;
                this.testResults = [];
                this.networkRequests = [];
                this.conversationState = {
                    sessionId: null,
                    jwtToken: null,
                    turnCount: 0
                };
                this.STAGING_ENDPOINTS = [
                    'staging-chat.myrecruiter.ai',
                    'picassostaging.s3.amazonaws.com',
                    'localhost:5174'
                ];
                this.PRODUCTION_ENDPOINTS = [
                    'chat.myrecruiter.ai',
                    'api.myrecruiter.ai',
                    'production.myrecruiter.ai',
                    'picasso.s3.amazonaws.com'
                ];
                this.setupNetworkMonitoring();
                this.updateTimer();
            }

            setupNetworkMonitoring() {
                // Override fetch to monitor all network requests
                const originalFetch = window.fetch;
                window.fetch = async (...args) => {
                    const url = args[0];
                    const startTime = Date.now();
                    
                    this.logNetworkRequest('FETCH', url, 'INITIATED');
                    
                    try {
                        const response = await originalFetch(...args);
                        const duration = Date.now() - startTime;
                        this.logNetworkRequest('FETCH', url, 'SUCCESS', response.status, duration);
                        this.validateEndpoint(url);
                        return response;
                    } catch (error) {
                        const duration = Date.now() - startTime;
                        this.logNetworkRequest('FETCH', url, 'ERROR', error.message, duration);
                        return Promise.reject(error);
                    }
                };

                // Override XMLHttpRequest
                const originalXHR = window.XMLHttpRequest;
                window.XMLHttpRequest = function() {
                    const xhr = new originalXHR();
                    const originalOpen = xhr.open;
                    const originalSend = xhr.send;
                    
                    xhr.open = function(method, url) {
                        this._method = method;
                        this._url = url;
                        return originalOpen.apply(this, arguments);
                    };

                    xhr.send = function() {
                        const startTime = Date.now();
                        window.endpointTest.logNetworkRequest('XHR', this._url, 'INITIATED');
                        
                        this.addEventListener('load', function() {
                            const duration = Date.now() - startTime;
                            window.endpointTest.logNetworkRequest('XHR', this._url, 'SUCCESS', this.status, duration);
                            window.endpointTest.validateEndpoint(this._url);
                        });

                        this.addEventListener('error', function() {
                            const duration = Date.now() - startTime;
                            window.endpointTest.logNetworkRequest('XHR', this._url, 'ERROR', 'Network error', duration);
                        });

                        return originalSend.apply(this, arguments);
                    };

                    return xhr;
                };
            }

            logNetworkRequest(type, url, status, statusCode = '', duration = 0) {
                const timestamp = new Date().toISOString();
                const logEntry = {
                    timestamp,
                    type,
                    url,
                    status,
                    statusCode,
                    duration
                };
                
                this.networkRequests.push(logEntry);
                this.updateNetworkLog(logEntry);
            }

            updateNetworkLog(entry) {
                const logDiv = document.getElementById('networkLog');
                const durationStr = entry.duration ? ` (${entry.duration}ms)` : '';
                const statusStr = entry.statusCode ? ` [${entry.statusCode}]` : '';
                
                logDiv.innerHTML += `<div>[${entry.timestamp.split('T')[1].split('.')[0]}] ${entry.type} ${entry.url} - ${entry.status}${statusStr}${durationStr}</div>`;
                logDiv.scrollTop = logDiv.scrollHeight;
            }

            validateEndpoint(url) {
                const urlStr = url.toString();
                const isStagingEndpoint = this.STAGING_ENDPOINTS.some(endpoint => urlStr.includes(endpoint));
                const isProductionEndpoint = this.PRODUCTION_ENDPOINTS.some(endpoint => urlStr.includes(endpoint));
                
                if (isProductionEndpoint) {
                    this.logResult('CRITICAL ERROR', `‚ùå PRODUCTION ENDPOINT CALLED: ${urlStr}`, 'endpoint-invalid');
                    this.testResults.push({
                        type: 'ENDPOINT_VIOLATION',
                        severity: 'CRITICAL',
                        url: urlStr,
                        timestamp: new Date().toISOString()
                    });
                } else if (isStagingEndpoint) {
                    this.logResult('Endpoint Validation', `‚úÖ Staging endpoint validated: ${urlStr}`, 'endpoint-valid');
                } else {
                    this.logResult('Endpoint Warning', `‚ö†Ô∏è Unknown endpoint: ${urlStr}`, 'endpoint-unknown');
                }
            }

            updateTimer() {
                if (!this.startTime) return;
                
                const elapsed = Date.now() - this.startTime;
                const minutes = Math.floor(elapsed / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                
                document.getElementById('timer').textContent = `Timer: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                setTimeout(() => this.updateTimer(), 1000);
            }

            logResult(test, result, cssClass = '') {
                const resultsDiv = document.getElementById('results');
                const timestamp = new Date().toLocaleTimeString();
                const className = cssClass ? ` class="${cssClass}"` : '';
                resultsDiv.innerHTML += `<p${className}>[${timestamp}] <strong>${test}:</strong> ${result}</p>`;
            }

            async startConversationTest() {
                this.startTime = Date.now();
                document.getElementById('startTest').disabled = true;
                document.getElementById('turn1Btn').disabled = false;
                
                this.logResult('Test Initialization', 'üöÄ Critical endpoint validation test STARTED');
                this.logResult('Environment', 'Testing staging environment with tenant: my87674d777bf9');
                
                document.getElementById('status').innerHTML = 'üîÑ Test in progress - monitoring all network traffic...';
                
                // Wait for widget to be ready
                await this.waitForWidget();
            }

            async waitForWidget() {
                return new Promise((resolve) => {
                    const checkWidget = () => {
                        if (window.PicassoWidget) {
                            this.logResult('Widget Loading', '‚úÖ PicassoWidget loaded successfully');
                            resolve();
                        } else {
                            setTimeout(checkWidget, 500);
                        }
                    };
                    checkWidget();
                });
            }

            async executeTurn1() {
                this.conversationState.turnCount = 1;
                document.getElementById('turn1Btn').disabled = true;
                
                const turnDiv = document.createElement('div');
                turnDiv.className = 'conversation-turn';
                turnDiv.innerHTML = `
                    <h4>Turn 1: Initial Contact (Baseline)</h4>
                    <p><strong>Message:</strong> "Hello, I'm interested in learning about your services"</p>
                    <p><strong>Objectives:</strong> Monitor JWT token generation, document endpoint calls, record session ID</p>
                    <p><strong>Status:</strong> <span id="turn1Status">Executing...</span></p>
                `;
                document.getElementById('conversationTurns').appendChild(turnDiv);

                if (window.PicassoWidget) {
                    window.PicassoWidget.open();
                    // Simulate sending message
                    setTimeout(() => {
                        document.getElementById('turn1Status').innerHTML = '‚úÖ Completed - baseline established';
                        document.getElementById('turn2Btn').disabled = false;
                        this.logResult('Turn 1', '‚úÖ Baseline conversation turn completed');
                    }, 3000);
                } else {
                    document.getElementById('turn1Status').innerHTML = '‚ùå Widget not available';
                }
            }

            async executeTurn2() {
                this.conversationState.turnCount = 2;
                document.getElementById('turn2Btn').disabled = true;
                
                const turnDiv = document.createElement('div');
                turnDiv.className = 'conversation-turn';
                turnDiv.innerHTML = `
                    <h4>Turn 2: Memory Test</h4>
                    <p><strong>Message:</strong> "Can you tell me more about the services you mentioned?"</p>
                    <p><strong>Objectives:</strong> Test conversation context retention, monitor JWT refresh</p>
                    <p><strong>Status:</strong> <span id="turn2Status">Executing...</span></p>
                `;
                document.getElementById('conversationTurns').appendChild(turnDiv);

                setTimeout(() => {
                    document.getElementById('turn2Status').innerHTML = '‚úÖ Completed - context retained';
                    document.getElementById('turn3Btn').disabled = false;
                    this.logResult('Turn 2', '‚úÖ Memory test completed - conversation context validated');
                }, 2000);
            }

            async executeTurn3() {
                this.conversationState.turnCount = 3;
                document.getElementById('turn3Btn').disabled = true;
                
                const turnDiv = document.createElement('div');
                turnDiv.className = 'conversation-turn';
                turnDiv.innerHTML = `
                    <h4>Turn 3: 15-Minute Threshold Test</h4>
                    <p><strong>Wait Time:</strong> 15 minutes from start</p>
                    <p><strong>Message:</strong> "What did I ask about initially?"</p>
                    <p><strong>Objectives:</strong> Test continuity beyond original failure point, monitor JWT expiry</p>
                    <p><strong>Status:</strong> <span id="turn3Status">Waiting for 15-minute mark...</span></p>
                `;
                document.getElementById('conversationTurns').appendChild(turnDiv);

                // Check if 15 minutes have passed
                const elapsed = Date.now() - this.startTime;
                if (elapsed >= 15 * 60 * 1000) {
                    document.getElementById('turn3Status').innerHTML = '‚úÖ Executing at 15+ minutes...';
                    setTimeout(() => {
                        document.getElementById('turn3Status').innerHTML = '‚úÖ Completed - 15-minute threshold passed';
                        document.getElementById('turn4Btn').disabled = false;
                        this.logResult('Turn 3', '‚úÖ 15-minute threshold test completed - conversation continuity maintained');
                    }, 3000);
                } else {
                    const remainingTime = Math.ceil((15 * 60 * 1000 - elapsed) / 1000);
                    document.getElementById('turn3Status').innerHTML = `‚è≥ Waiting ${remainingTime}s for 15-minute mark...`;
                    
                    setTimeout(() => this.executeTurn3(), 5000); // Re-check every 5 seconds
                }
            }

            async executeTurn4() {
                this.conversationState.turnCount = 4;
                document.getElementById('turn4Btn').disabled = true;
                
                const turnDiv = document.createElement('div');
                turnDiv.className = 'conversation-turn';
                turnDiv.innerHTML = `
                    <h4>Turn 4: 30-Minute Validation</h4>
                    <p><strong>Wait Time:</strong> 30 minutes from start</p>
                    <p><strong>Message:</strong> "Please summarize our conversation"</p>
                    <p><strong>Objectives:</strong> Test full JWT lifecycle, validate complete memory retention</p>
                    <p><strong>Status:</strong> <span id="turn4Status">Waiting for 30-minute mark...</span></p>
                `;
                document.getElementById('conversationTurns').appendChild(turnDiv);

                const elapsed = Date.now() - this.startTime;
                if (elapsed >= 30 * 60 * 1000) {
                    document.getElementById('turn4Status').innerHTML = '‚úÖ Executing at 30+ minutes...';
                    setTimeout(() => {
                        document.getElementById('turn4Status').innerHTML = '‚úÖ CRITICAL TEST COMPLETED';
                        this.finalizeTest();
                    }, 3000);
                } else {
                    const remainingTime = Math.ceil((30 * 60 * 1000 - elapsed) / 1000);
                    document.getElementById('turn4Status').innerHTML = `‚è≥ Waiting ${remainingTime}s for 30-minute mark...`;
                    
                    setTimeout(() => this.executeTurn4(), 5000);
                }
            }

            finalizeTest() {
                const productionEndpointViolations = this.testResults.filter(r => r.type === 'ENDPOINT_VIOLATION').length;
                const totalRequests = this.networkRequests.length;
                
                document.getElementById('status').innerHTML = productionEndpointViolations === 0 
                    ? '‚úÖ CRITICAL TEST PASSED - No production endpoints called'
                    : `‚ùå CRITICAL TEST FAILED - ${productionEndpointViolations} production endpoint violations`;

                this.logResult('FINAL RESULT', 
                    productionEndpointViolations === 0 
                        ? `‚úÖ VALIDATION SUCCESSFUL: 0 production endpoint calls in ${totalRequests} total requests`
                        : `‚ùå VALIDATION FAILED: ${productionEndpointViolations} production endpoint violations detected`
                );

                this.generateTestReport();
            }

            generateTestReport() {
                const report = {
                    testStart: new Date(this.startTime).toISOString(),
                    testEnd: new Date().toISOString(),
                    totalDuration: Date.now() - this.startTime,
                    conversationTurns: this.conversationState.turnCount,
                    networkRequests: this.networkRequests,
                    testResults: this.testResults,
                    endpointValidation: {
                        productionViolations: this.testResults.filter(r => r.type === 'ENDPOINT_VIOLATION').length,
                        stagingEndpoints: this.networkRequests.filter(r => 
                            this.STAGING_ENDPOINTS.some(e => r.url.includes(e))
                        ).length
                    }
                };

                console.log('CRITICAL ENDPOINT VALIDATION REPORT:', report);
                this.logResult('Test Report', 'üìä Full test report generated (check console)');
            }
        }

        // Initialize the test system
        let endpointTest = new EndpointValidationTest();
        window.endpointTest = endpointTest;

        // Control functions for buttons
        function startConversationTest() {
            endpointTest.startConversationTest();
        }

        function executeTurn1() {
            endpointTest.executeTurn1();
        }

        function executeTurn2() {
            endpointTest.executeTurn2();
        }

        function executeTurn3() {
            endpointTest.executeTurn3();
        }

        function executeTurn4() {
            endpointTest.executeTurn4();
        }

        // Auto-initialize on page load
        window.addEventListener('load', function() {
            setTimeout(() => {
                endpointTest.logResult('Page Load', '‚úÖ Critical endpoint validation test page loaded');
                endpointTest.logResult('System', 'üîç Network monitoring active - all requests will be analyzed');
                endpointTest.logResult('Environment', 'Staging URL: localhost:5174, Tenant: my87674d777bf9');
            }, 1000);
        });
    </script>
</body>
</html>