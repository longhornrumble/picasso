<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Picasso Widget</title>
  <style>
    /* Iframe-specific CSS reset and isolation */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: system-ui, -apple-system, sans-serif;
      background: transparent;
    }
    
    #root {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    
    /* Prevent any parent page styles from leaking in */
    * {
      box-sizing: border-box;
    }
    
    /* Basic iframe setup - let the React component handle the rest */
    .loading-indicator {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      background: #f8f9fa;
      color: #6c757d;
      font-family: system-ui, -apple-system, sans-serif;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="root">
    <div class="loading-indicator">
      üé® Loading Picasso Widget...
    </div>
  </div>
  
  <!-- Global environment detection (avoid redeclaration) -->
  <script>
    // Single global isDev variable to avoid redeclaration errors
    window.picassoIsDev = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
  </script>
  
  <!-- Manual React Refresh preamble injection for iframe context -->
  <script type="module">
    // Use global isDev variable
    if (window.picassoIsDev) {
      try {
        // Import and inject React Refresh runtime
        const port = window.location.port || '5173';
        const RefreshRuntime = await import(`http://localhost:${port}/@react-refresh`);
        RefreshRuntime.injectIntoGlobalHook(window);
        
        // Set up required globals for React Refresh
        window.$RefreshReg$ = () => {};
        window.$RefreshSig$ = () => (type) => type;
        window.__vite_plugin_react_preamble_installed__ = true;
        
        console.log('‚úÖ React Refresh preamble injected successfully');
      } catch (error) {
        console.log('‚ö†Ô∏è React Refresh not available (normal in production):', error.message);
      }
    }
  </script>
  
  <!-- Vite client for HMR (development only) -->
  <script>
    if (window.picassoIsDev) {
      const script = document.createElement('script');
      script.type = 'module';
      const port = window.location.port || '5173';
      script.src = `http://localhost:${port}/@vite/client`;
      script.onerror = () => console.log('‚ö†Ô∏è Vite client not available');
      document.head.appendChild(script);
    }
  </script>

  <script>
    // Debug URL parameters
    console.log('üîç Current URL:', window.location.href);
    console.log('üîç URL Parameters:', new URLSearchParams(window.location.search).toString());
    const urlParams = new URLSearchParams(window.location.search);
    const tenantHash = urlParams.get('t');
    console.log('üîë Detected tenant hash from URL:', tenantHash || 'none');
    
    // Communication bridge with parent window
    function notifyParent(data) {
      if (window.parent && window.parent !== window) {
        window.parent.postMessage({
          type: 'PICASSO_WIDGET',
          ...data
        }, '*');
      }
    }

    // Monitor chat state changes for iframe resizing
    function setupStateMonitoring() {
      console.log('üîß Setting up state monitoring...');
      
      // Ensure document.body exists and is properly initialized
      if (!document || !document.body || typeof document.body.classList === 'undefined') {
        console.warn('‚ö†Ô∏è Document body not ready for state monitoring, retrying in 100ms');
        setTimeout(setupStateMonitoring, 100);
        return;
      }
      
      let lastOpenState = null;
      
      // Function to check and notify state changes
      function checkStateChange() {
        try {
          const isOpen = document.body.classList.contains('chat-open');
          if (isOpen !== lastOpenState) {
            lastOpenState = isOpen;
            notifyParent({
              action: 'SIZE_CHANGE',
              isOpen: isOpen,
              size: isOpen ? { width: 360, height: 640 } : { width: 56, height: 56 }
            });
            console.log(`üìè State changed: ${isOpen ? 'OPEN' : 'CLOSED'}`);
          }
        } catch (error) {
          console.warn('‚ö†Ô∏è Error checking state:', error);
        }
      }
      
      // Try MutationObserver first (preferred)
      if (typeof MutationObserver !== 'undefined') {
        try {
          const observer = new MutationObserver((mutations) => {
            for (const mutation of mutations) {
              if (mutation.type === 'attributes' && 
                  mutation.attributeName === 'class' && 
                  mutation.target === document.body) {
                checkStateChange();
                break;
              }
            }
          });

          observer.observe(document.body, {
            attributes: true,
            attributeFilter: ['class'],
            subtree: false
          });
          
          console.log('‚úÖ MutationObserver setup successfully');
        } catch (error) {
          console.warn('‚ö†Ô∏è MutationObserver failed, falling back to polling:', error);
          // Fallback to polling
          setInterval(checkStateChange, 200);
        }
      } else {
        console.log('üìä Using polling fallback for state monitoring');
        setInterval(checkStateChange, 200);
      }
      
      // Initial state check
      setTimeout(checkStateChange, 100);
    }

    // Initialize monitoring when DOM is ready
    function initializeWhenReady() {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
          console.log('‚úÖ DOM loaded, setting up monitoring');
          setTimeout(setupStateMonitoring, 50); // Small delay to ensure everything is ready
        });
      } else {
        console.log('‚úÖ DOM already ready, setting up monitoring');
        setTimeout(setupStateMonitoring, 50);
      }
    }
    
    // Initialize
    initializeWhenReady();
    
    // Dynamically load the iframe script based on environment
    function loadIframeScript() {
      if (!document.head) {
        console.error('‚ùå Document head not available for script loading');
        return;
      }
      
      const script = document.createElement('script');
      
      // Use global isDev variable (no redeclaration)
      if (window.picassoIsDev) {
        // Development mode - load from Vite dev server
        script.type = 'module';
        script.src = '/src/iframe-main.jsx';
      } else {
        // Production mode - load built version
        script.src = '/iframe-main.js';
      }
      
      script.onerror = function() {
        console.error('‚ùå Failed to load iframe script:', script.src);
      };
      
      script.onload = function() {
        console.log('‚úÖ Iframe script loaded:', script.src);
      };
      
      // Small delay to ensure preamble is loaded first
      setTimeout(() => {
        try {
          document.head.appendChild(script);
          console.log('‚úÖ Script appended to head');
        } catch (error) {
          console.error('‚ùå Failed to append script:', error);
        }
      }, 100);
    }
    
    // Load the script after preamble setup
    loadIframeScript();
  </script>
</body>
</html> 